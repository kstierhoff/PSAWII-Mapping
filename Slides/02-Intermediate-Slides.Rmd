---
title: "Mapping and Spatial Analysis in R!"
subtitle: "Part 2-Manipulating and Analyzing Spatial Data"
date: '`r format(Sys.time(), format = "%F")`'
output:
  xaringan::moon_reader:
    css: ["default","css/css-slides.css"]
    lib_dir: libs
    nature:
      ratio: 16:9
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
---

```{r setup, include=FALSE}
# Install and load pacman (library management package)
if (!require("pacman")) install.packages("pacman")

# Install and load required packages from CRAN ----
pacman::p_load(xaringan,knitr,here,tidyverse,sf,
               rnaturalearth)

options(htmltools.dir.version = FALSE)
knitr::opts_chunk$set(message = F, fig.align = 'center',
                      fig.dim = c(6.5, 6.1), fig.retina = 2, 
                      out.height = "100%")
knitr::opts_hooks$set(fig.callout = function(options) {
  if (options$fig.callout) {
    options$echo <- FALSE
    options$out.height <- "99%"
    options$fig.width <- 16
    options$fig.height <- 8
  }
  options
})

# Set ggplot2 theme
theme_set(theme_bw())
```

## What are the advantages of working with spatial data?
- As with any other GIS, you can plot data with different CRS on the same plot

- The GIS does the projection on the fly and locates points/lines/polygons in the correct<sup>*</sup> space

- Perhaps you'd like to be able to convert between coordinate systems for different analyses
  - Computing area over broad geographic range can be quite inaccurate using WGS84
  - Converting to an equal area projection (e.g., Albers) would provide a more accurate result

  
_(I'm sure there are many other compelling reasons)_

.footnote[
[*] There may be some distortion or inaccuracy at different scales, and some functions will provide warnings.
]

---

background-image: url(images/raster-vector.jpg)
background-size: 500px
background-position: 90% 50%

## **Vector** vs. **Raster** data?
.pull-left[
From Lovelace et al. _Geocomputation with R_:  

- The geographic **vector** model is based on points located within a coordinate reference system (CRS). Points can represent self-standing features (e.g., the location of a bus stop) or they can be linked together to form more complex geometries such as lines and polygons. 

- In contrast, **raster** data are made up of pixels (also referred to as grid cells). They are usually regularly-spaced and square but they donâ€™t have to be. Rasters often look pixelated because each pixel has its own value or class.
  - **Discrete:** have distinct themes or categories. For example, one grid cell represents a land cover class or a soil type.
  - **Continuous:** (non-discrete) are grid cells with gradual changing data such as elevation, temperature or an aerial photograph.
]

---

## Why use `sf` instead of `sp` for vector data?
Some of you may be familiar with the `sp` package and `Spatial*DataFrames`.

From Lovelace et al. _Geocomputation with R_: 

**`sf`** is a package providing a class system for geographic vector data. Not only does **`sf`** supersede **`sp`**, it also provides a consistent command-line interface to **`GEOS`** (Geometry Engine - Open Source C++ library) and **`GDAL`** (Geospatial Data Abstraction Library), superseding **`rgeos`** and **`rgdal`**.

Simple features is an open standard developed and endorsed by the not-for-profit Open Geospatial Consortium (OGC). 

Simple Features is a hierarchical data model that represents a wide range of geometry types. Of 17 geometry types supported by the specification, only 7 are used in the vast majority of geographic research; these core geometry types are fully supported by the **`sf`**.  

**Spatial objects can be readily converted between `sf` and `sp` format.**

```{r,eval=F}
# From sf to sp
sf.to.sp <- as(sf, 'Spatial')

# From sp to sf
sp.to.sf <- st_as_sf(sp)
```

---

## Spatial data objects  

- The `sf` package is all you really need to create, transform, read, and write spatial data files

- Most functions take the name `st_*()`

  - `st_read()` and `st_write()` to read and write shapefiles
  - `st_as_sf(coords = ("",""), crs = "")` to create sf object from data frame
  - `st_transform()` to convert between coordinate reference systems (CRS)
  - `st_bbox()` to get the bounding box of a spatial data set

- The `tidyverse` packages (e.g., `dplyr`) work wonderfully with `sf` objects

  - `filter()` and `select()` to subset rows and columns, respectively
  - `mutate()` to create new variables
  - `left_join()`, `right_join()`, `inner_join()`, etc. for merging with other data

We'll look at these in more depth throughout this section

---

## Spatial data objects  

Recall:

```{r}
methods(class = "sf")
```

---

## Create an `sf` object

.pull-left[
Read our CPS backscatter data again and view it's contents

```{r}
# Read data file
cps <- read_csv(here("Data/cps.csv")) %>% 
  select(transect, interval, everything())

# View data
cps
```
]

--

.pull-right[
Convert data frame to a simple feature using `st_as_sf()`

```{r}
# Define coordinates and CRS
cps.sf <- st_as_sf(cps, 
                   coords = c("long","lat"),
                   crs = 4326)

# View data
cps.sf[1:3, ]
```
]

---

## What's a geometry column?
The `geometry` column is a list-column, and it's **sticky**. 

What happens if we select only the `nasc` column?

.pull-left[
```{r}
# Data frame
select(cps, nasc) %>% head(5)
```
]

--

.pull-right[
```{r}
# Simple feature
select(cps.sf, nasc) %>% head(5)
```
]

---
## Convert from `sf` to data.frame

To convert back to a data frame, use `st_set_geometry(NULL)`

.pull-left[
```{r}
# Define coordinates and CRS
cps.sf %>% 
  st_set_geometry(NULL) %>% 
  head(3)
```

-- 

**But where did the lat/long go?!?**
]  

--

.pull-right[
```{r}
# Create lat/long vars first
cps.sf %>% 
  mutate(
    long = as.data.frame(st_coordinates(.))$X,
    lat = as.data.frame(st_coordinates(.))$Y) %>% 
  st_set_geometry(NULL) %>% 
  head(3)
```

]

--

**Why would you want to do this?**

Perhaps if you'd like to write to a CSV, which doesn't support list-columns?

---

## Viewing spatial objects (`base::print`)
`sf` objects have their own print methods, so you can have a visual summary using `print()`

.pull-left[
```{r}
# Get California using rnaturalearth
usa <- ne_states(
  country = c("United States of America"), 
  returnclass = 'sf') %>% 
  filter(!name %in% c("Alaska","Hawaii")) %>% 
  select("name","region_sub")

# View top rows
head(usa, 3)
```
]

.pull-right[
```{r}
# Plot 
plot(usa["region_sub"])
```

]

---

## Viewing spatial objects (`ggplot2`)
Since `ggplot2` version 3.1, `sf` support by `geom_sf`

```{r,out.height='100%'}
# Plot using ggplot and WGS84
ggplot(usa) + 
  geom_sf(aes(fill = region_sub)) +
  coord_sf(crs = 4326) #<<
```

---

## Viewing spatial objects (`ggplot2`)
The magic of `coord_sf()` and projections

```{r}
laea = st_crs("+proj=laea +lat_0=30 +lon_0=-95") # Lambert equal area

# Plot using ggplot
ggplot(usa) + 
  geom_sf(aes(fill = region_sub)) +
  coord_sf(crs = laea)
```


---

## Viewing spatial objects (`mapview`)




